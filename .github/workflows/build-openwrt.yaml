# Copyright (c) 2023 LENAR
#
# This is free software, licensed under the MIT License.
# See /LICENSE for more information.
#
name: Build OpenWrt Firmware

on:
  repository_dispatch:
  workflow_dispatch:
    inputs:
      branch:
        description: "Source Branch"
        type: choice
        required: true
        options:
          - openwrt-23.05.5
          - openwrt-23.05
          - openwrt-24.10
      config_file:
        description: "Config Name"
        type: choice
        required: true
        options:
          - openwrt.config
      config_link:
        description: "Use Config URL"
        type: boolean
        default: false
      config_url:
        description: "Config URL"
        type: string
        required: false
        default: ""
      diy:
        description: "DIY Script"
        type: choice
        required: true
        options:
          - diy_v1.sh
          - diy_v2.sh
      firmware_release:
        description: "Firmware Release"
        type: boolean
        default: false
      # toolchain_release, toolchain_rebuild, vermagic больше не нужны,
      # так как toolchain не кэшируется и vermagic обновляется всегда
      # toolchain_release:
      #   description: "Toolchain Release"
      #   type: boolean
      #   default: true
      # toolchain_rebuild:
      #   description: "Force Rebuild Toolchain"
      #   type: boolean
      #   default: false
      vermagic:
        description: "Inject official kernel vermagic for kmod compatibility"
        type: boolean
        default: true # Vermagic всегда будем использовать, так как toolchain не кэшируется

env:
  SOURCE_URL: https://github.com/recrumptor/openwrt # URL репозитория OpenWrt для клонирования
  SOURCE_ORIGIN: https://github.com/recrumptor/openwrt # Для слияния upstream изменений
  SOURCE_BRANCH: ${{ github.event.inputs.branch }}
  FEEDS_SH: feeds.sh
  FEEDS_PKG_SH: feeds_pkg.sh
  CONFIG_FILE: ${{ github.event.inputs.config_file }}
  CONFIG_LINK: ${{ github.event.inputs.config_link }}
  CONFIG_URL: ${{ github.event.inputs.config_url }}
  DIY_SH: ${{ github.event.inputs.diy }}
  FIRMWARE_RELEASE: ${{ github.event.inputs.firmware_release }}
  # TOOLCHAIN_RELEASE: ${{ github.event.inputs.toolchain_release }} # Удалено
  # TOOLCHAIN_REBUILD: ${{ github.event.inputs.toolchain_rebuild }} # Удалено
  VERMAGIC: ${{ github.event.inputs.vermagic }}
  TOKEN: ${{ secrets.GITHUB_TOKEN }}
  TZ: UTC
  BUILD_ROOT_DIR: openwrt_source # Новая директория для клонирования OpenWrt

jobs:
  # Джоба Toolchain удалена полностью
  # Toolchain:
  #   ... (удалено)

  Build:
    name: Build OpenWrt Firmware
    # needs: [Toolchain] # Больше не зависит от джобы Toolchain
    runs-on: ubuntu-22.04 # Используем ubuntu-22.04, как было у вас, хотя в примере 24.04

    steps:
      - name: Initialize Environment
        run: |
          sudo timedatectl set-timezone "$TZ"
          mkdir -p workspace # Создаем рабочую директорию
          df -hT
          ulimit -n 8192

      - name: Maximize Build Space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: '4096'
          temp-reserve-mb: '2048'
          swap-size-mb: '2048'
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'

      - name: Checkout Your Repository (for scripts and configs)
        uses: actions/checkout@v4
        # Этот шаг клонирует ваш репозиторий (с feeds.sh, diy_vX.sh, config/, vermagic_update.sh)
        # в $GITHUB_WORKSPACE. Отсюда мы будем копировать файлы в склонированный OpenWrt.

      - name: "Debug: List contents after checkout"
        run: |
          echo "--- Contents of ${{ github.workspace }}/ ---"
          ls -RF "${{ github.workspace }}"
          echo "--- End of Contents ---"

      - name: Install Packages
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo -E apt-get -qq update
          # Устанавливаем зависимости. curl необходим для скачивания списка зависимостей.
          # kmod тут остается, так как он может быть в списке зависимостей.
          # squashfs-tools тоже можно оставить, может пригодиться для других операций,
          # но для распаковки toolchain больше не нужен.
          sudo -E apt-get -qq install -y $(curl -fsSL https://pastebin.com/raw/y5mk4S1a)
          sudo -E apt-get -qq autoremove --purge
          sudo -E apt-get -qq clean
          df -hT
          # Строки про modprobe overlay удалены, т.к. overlayfs больше не используется
          
      - name: Clone OpenWrt Source Code
        id: clone_openwrt
        run: |
          # Клонируем OpenWrt в директорию внутри workspace
          git clone --single-branch "$SOURCE_URL" -b "$SOURCE_BRANCH" workspace/$BUILD_ROOT_DIR
          
          cd workspace/$BUILD_ROOT_DIR
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git remote add upstream "$SOURCE_ORIGIN" || true # Добавляем upstream, если еще нет
          git fetch upstream "$SOURCE_BRANCH"
          git merge upstream/"$SOURCE_BRANCH"

          # Устанавливаем OPENWRT_ROOT_PATH на склонированный OpenWrt
          echo "OPENWRT_ROOT_PATH=$(realpath .)" >> "$GITHUB_ENV"
          echo "OpenWrt source cloned to $OPENWRT_ROOT_PATH"
          
      - name: Copy Builder Files into OpenWrt Source (using rsync as in example)
        run: |
          # Копируем содержимое вашего репозитория (скрипты, конфиги, vermagic_update.sh)
          # в склонированный репозиторий OpenWrt.
          # Исключаем .git, workspace/ и саму директорию OpenWrt, чтобы не скопировать лишнее.
          rsync -avq --exclude=".git/" --exclude="workspace/" --exclude="$BUILD_ROOT_DIR/" "${{ github.workspace }}/" "$OPENWRT_ROOT_PATH/"
          
          # Отладочный вывод, чтобы убедиться, что файлы скопировались
          echo "--- Contents of $OPENWRT_ROOT_PATH/ after rsync ---"
          ls -F "$OPENWRT_ROOT_PATH/"
          echo "--- End of Contents ---"

      - name: Generate Variables (Moved from Toolchain Job, adjusted)
        id: env
        run: |
          export SOURCE_OWNER=$(echo "$SOURCE_URL" | awk -F '/' '{print $(NF-1)}')
          echo "SOURCE_OWNER=$SOURCE_OWNER" >> "$GITHUB_ENV"
          echo "SOURCE_OWNER=$SOURCE_OWNER" >> "$GITHUB_OUTPUT"
          export SOURCE_REPO=$(echo "$SOURCE_URL" | awk -F '/' '{print $NF}' | sed 's/\.git$//')
          echo "SOURCE_REPO=$SOURCE_REPO" >> "$GITHUB_ENV"
          echo "SOURCE_REPO=$SOURCE_REPO" >> "$GITHUB_OUTPUT"
          
          cd "$OPENWRT_ROOT_PATH"
          export CURRENT_BRANCH=$(git symbolic-ref --short HEAD)
          echo "CURRENT_BRANCH=$CURRENT_BRANCH" >> "$GITHUB_ENV"
          echo "CURRENT_BRANCH=$CURRENT_BRANCH" >> "$GITHUB_OUTPUT"
          
          # Копируем .config, теперь он должен быть в ${{ github.workspace }}/config/
          if [[ "$CONFIG_LINK" == "true" && -n "$CONFIG_URL" ]]; then
            curl -s "$CONFIG_URL" -o ".config"
          else
            # Предполагаем, что config/ находится в корне вашего репозитория,
            # и он был скопирован rsync'ом в $OPENWRT_ROOT_PATH
            cp "config/$CONFIG_FILE" ".config"
          fi
          make defconfig
          
          export DEVICE_NAME=$(grep 'CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/')
          echo "DEVICE_NAME=$DEVICE_NAME" >> "$GITHUB_ENV"
          echo "DEVICE_NAME=$DEVICE_NAME" >> "$GITHUB_OUTPUT"
          export DEVICE_PLATFORM=$(grep 'CONFIG_TARGET_ARCH_PACKAGES' .config | awk -F '"' '{print $2}')
          echo "DEVICE_PLATFORM=$DEVICE_PLATFORM" >> "$GITHUB_ENV"
          echo "DEVICE_PLATFORM=$DEVICE_PLATFORM" >> "$GITHUB_OUTPUT"
          export DEVICE_TARGET=$(grep 'CONFIG_TARGET_BOARD' .config | awk -F '"' '{print $2}')
          echo "DEVICE_TARGET=$DEVICE_TARGET" >> "$GITHUB_ENV"
          echo "DEVICE_TARGET=$DEVICE_TARGET" >> "$GITHUB_OUTPUT"
          export DEVICE_SUBTARGET=$(grep 'CONFIG_TARGET_SUBTARGET' .config | awk -F '"' '{print $2}')
          echo "DEVICE_SUBTARGET=$DEVICE_SUBTARGET" >> "$GITHUB_ENV"
          echo "DEVICE_SUBTARGET=$DEVICE_SUBTARGET" >> "$GITHUB_OUTPUT"
          
          # TOOLCHAIN_IMAGE и CURRENT_HASH больше не используются для кэширования
          # Но BUILD_DATE все еще полезен
          export BUILD_DATE=$(date +"%Y-%m-%d-%H%M")
          echo "BUILD_DATE=$BUILD_DATE" >> "$GITHUB_ENV"
          echo "BUILD_DATE=$BUILD_DATE" >> "$GITHUB_OUTPUT"
          
          # REBUILD_CHECK тоже больше не нужен, т.к. всегда будет полная сборка toolchain
          # echo "REBUILD_CHECK=true" >> "$GITHUB_OUTPUT" # Это можно удалить

      # Шаги Get Release Hash, Compare Toolchain Hash, Install Feeds (Toolchain),
      # Compile Tools, Compile Toolchain, Generate Toolchain Image, Upload Toolchain Image To Artifact,
      # Delete Old Toolchain Assets From Release, Upload Toolchain Image To Release - УДАЛЕНЫ
      # Они были частью джобы Toolchain и больше не нужны.

      - name: Load Custom Configuration # Этот шаг частично объединен с Generate Variables выше, но оставляем для ясности
        run: |
          cd "$OPENWRT_ROOT_PATH"
          # .config уже скопирован и применен в Generate Variables

      - name: Inject Correct Kernel Vermagic from official source
        if: ${{ env.VERMAGIC == 'true' }} # Условие остается, хотя VERMAGIC теперь всегда 'true'
        run: |
          # vermagic_update.sh должен был быть скопирован rsync'ом
          cd "$OPENWRT_ROOT_PATH"
          chmod +x ./vermagic_update.sh
          ./vermagic_update.sh ${{ env.DEVICE_TARGET }} ${{ env.DEVICE_SUBTARGET }}
        env:
          REPO_URL: https://downloads.openwrt.org/snapshots/

      - name: Load Custom Feeds
        run: |
          # feeds.sh должен был быть скопирован rsync'ом
          cd "$OPENWRT_ROOT_PATH"
          chmod +x "./$FEEDS_SH" && "./$FEEDS_SH"

      - name: Install Feeds
        run: |
          cd "$OPENWRT_ROOT_PATH"
          
          ./scripts/feeds clean

          git config --global http.postBuffer 524288000
          git config --global http.lowSpeedLimit 0
          git config --global http.lowSpeedTime 999999

          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
              echo "--- Попытка обновления фидов $((RETRY_COUNT + 1)) из $MAX_RETRIES ---"
              if ./scripts/feeds update -a V=s; then
                  echo "feeds update -a успешно завершено."
                  break
              else
                  echo "feeds update -a завершилось ошибкой. Повтор через 15 секунд..."
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                  sleep 15
              fi
          done

          if [ "$RETRY_COUNT" -eq "$MAX_RETRIES" ]; then
              echo "feeds update -a не удалось после $MAX_RETRIES попыток. Прерываю сборку."
              exit 1
          fi

          # feeds_pkg.sh должен был быть скопирован rsync'ом
          cp "${{ github.workspace }}/scripts/$FEEDS_PKG_SH" "$OPENWRT_ROOT_PATH/$FEEDS_PKG_SH" # Это не нужно, если rsync копирует scripts/
          chmod +x "./$FEEDS_PKG_SH" && "./$FEEDS_PKG_SH"

          ./scripts/feeds install -a V=s

      - name: Upload Config To Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Config
          path: ${{ env.OPENWRT_ROOT_PATH }}/.config
          include-hidden-files: true
          retention-days: 7

      - name: Load DIY
        run: |
          # diy_vX.sh должен был быть скопирован rsync'ом
          # cp "${{ github.workspace }}/scripts/$DIY_SH" "$OPENWRT_ROOT_PATH/$DIY_SH" # Это не нужно, если rsync копирует scripts/
          
          # Если директория 'custom' есть в вашем репозитории, rsync ее скопирует.
          # Этот блок можно удалить, если custom/ всегда будет в корне OpenWrt
          # if [ -d "${{ github.workspace }}/custom" ]; then
          #   mv "${{ github.workspace }}/custom" "$OPENWRT_ROOT_PATH/custom"
          # fi
          
          cd "$OPENWRT_ROOT_PATH"
          chmod +x "./$DIY_SH" && "./$DIY_SH"

      - name: Download Packages
        id: download
        run: |
          cd "$OPENWRT_ROOT_PATH"
          make download -j$(($(nproc) + 1)) || make download -j1 V=s # Используем (nproc)+1 для более эффективного использования ядер
          find dl -size -1024c -exec ls -l {} \;
          find dl -size -1024c -exec rm -f {} \;

      - name: Compile Packages
        run: |
          cd "$OPENWRT_ROOT_PATH"
          echo -e "$(nproc) Thread Compile"
          make clean
          make buildinfo
          make diffconfig buildversion feedsversion
          make target/compile -j$(($(nproc) + 1)) IGNORE_ERRORS="m n" BUILD_LOG=1 || \
          yes n | make target/compile -j1 V=s IGNORE_ERRORS=1 # Сделал более устойчивым к ошибкам, как вы раньше просили
          make package/compile -j$(($(nproc) + 1)) IGNORE_ERRORS=1 || make package/compile -j1 V=s IGNORE_ERRORS=1
          make package/index

      - name: Get Compiled Kernel Vermagic
        run: |
          cd "$OPENWRT_ROOT_PATH"
          
          BUILD_DIR_PATH="build_dir/target-${{ env.DEVICE_PLATFORM }}/linux-${{ env.DEVICE_TARGET }}_${{ env.DEVICE_SUBTARGET }}"
          
          KERNEL_DIR=$(find "$BUILD_DIR_PATH" -maxdepth 1 -type d -name "linux-*" | head -n 1)

          if [ -z "$KERNEL_DIR" ]; then
            echo "Ошибка: KERNEL_DIR не найдена. Ожидаемый путь: '$BUILD_DIR_PATH/linux-*'."
            echo "Пожалуйста, проверьте содержимое '$BUILD_DIR_PATH/' для отладки:"
            ls -R "$BUILD_DIR_PATH"/ || true
            exit 1
          fi
          echo "Отладка: Обнаружена директория KERNEL_DIR: $KERNEL_DIR"
          
          if [ -f "$KERNEL_DIR/.vermagic" ]; then
            echo "--- VERMAGIC из файла .vermagic (ОСНОВНОЙ) ---"
            VERMAGIC_FROM_FILE=$(cat "$KERNEL_DIR/.vermagic")
            echo "$VERMAGIC_FROM_FILE"
            echo "build_vermagic=$VERMAGIC_FROM_FILE" >> "$GITHUB_OUTPUT"
          else
            echo "Внимание: Файл .vermagic не найден в "$KERNEL_DIR". Попытка извлечь из kmod."
          fi

          TUN_IPK_PATH="bin/targets/${{ env.DEVICE_TARGET }}/${{ env.DEVICE_SUBTARGET }}/packages"
          TUN_IPK_FILE=$(find "$TUN_IPK_PATH" -name "kmod-tun_*.ipk" | head -n 1)

          if [ -n "$TUN_IPK_FILE" ]; then
            echo "--- VERMAGIC из kmod-tun.ko (ДОПОЛНИТЕЛЬНЫЙ) ---"
            mkdir -p ./tmp_mod_extract/
            
            tar -xf "$TUN_IPK_FILE" -C ./tmp_mod_extract/
            
            if [ ! -f ./tmp_mod_extract/data.tar.gz ]; then
              echo "Ошибка: data.tar.gz не найден после распаковки IPK. Проверьте структуру IPK: $TUN_IPK_FILE"
              rm -rf ./tmp_mod_extract/
              exit 1
            fi

            tar -xzf ./tmp_mod_extract/data.tar.gz -C ./tmp_mod_extract/
            
            TUN_KO=$(find ./tmp_mod_extract/ -name "tun.ko" | head -n 1)
            
            if [ -n "$TUN_KO" ]; then
                VERMAGIC_STRING=""
                if command -v modinfo &> /dev/null; then
                    VERMAGIC_STRING=$(modinfo "$TUN_KO" | grep ^vermagic | awk '{print $2}')
                    echo "Vermagic (через modinfo): $VERMAGIC_STRING"
                else
                    VERMAGIC_STRING=$(strings "$TUN_KO" | grep -oE '^5\.15\.[0-9]+[^ ]*' | head -n 1)
                    echo "Vermagic (через strings): $VERMAGIC_STRING"
                fi
                
                echo "build_vermagic_from_kmod=$VERMAGIC_STRING" >> "$GITHUB_OUTPUT"
            else
                echo "Внимание: tun.ko не найден внутри распакованного IPK."
            fi
            rm -rf ./tmp_mod_extract/ control.tar.gz data.tar.gz
          else
            echo "Внимание: IPK kmod-tun не найден. Невозможно извлечь vermagic из модуля. Убедитесь, что CONFIG_PACKAGE_kmod-tun=m находится в .config."
          fi
          
      - name: Generate Firmware
        id: generate
        run: |
          cd "$OPENWRT_ROOT_PATH"
          make package/install -j$(($(nproc) + 1)) || make package/install -j1 V=s
          make target/install -j$(($(nproc) + 1)) || make target/install -j1 V=s
          make json_overview_image_info
          make checksum
          echo "::notice title=Firmware Build Summary::Firmware for ${{ env.DEVICE_NAME }} built successfully. Check bin/targets/${{ env.DEVICE_TARGET }}/${{ env.DEVICE_SUBTARGET }} for images."

      - name: Upload Bin To Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SOURCE_REPO }}-${{ env.DEVICE_NAME }}-${{ env.BUILD_DATE }}
          path: ${{ env.OPENWRT_ROOT_PATH }}/bin
          retention-days: 7

      - name: Organize Files
        if: ${{ env.FIRMWARE_RELEASE == 'true' }}
        run: |
          cd "$OPENWRT_ROOT_PATH/bin/targets/$DEVICE_TARGET/$DEVICE_SUBTARGET"
          rm -rf packages feeds.buildinfo profiles.json version.buildinfo
          df -hT "$PWD"

      - name: Archive Firmware Files
        if: ${{ env.FIRMWARE_RELEASE == 'true' }}
        run: |
          cd "${{ env.OPENWRT_ROOT_PATH }}/bin/targets/${{ env.DEVICE_TARGET }}/${{ env.DEVICE_SUBTARGET }}"
          zip -r "firmware-${{ env.DEVICE_NAME }}-${{ env.BUILD_DATE }}.zip" ./*
          mv "firmware-${{ env.DEVICE_NAME }}-${{ env.BUILD_DATE }}.zip" "$GITHUB_WORKSPACE/"
          df -hT "$PWD"
          ls -lh "$GITHUB_WORKSPACE/"

      - name: Deploy Files To Release
        if: ${{ env.FIRMWARE_RELEASE == 'true' }}
        uses: ncipollo/release-action@v1
        with:
          token: ${{ env.TOKEN }}
          name: "OpenWrt Firmware - ${{ env.SOURCE_BRANCH }} (${{ env.DEVICE_TARGET }}_${{ env.DEVICE_SUBTARGET}})"
          commit: ${{ env.CURRENT_BRANCH }}
          tag: firmware-${{ env.SOURCE_BRANCH }}-${{ env.BUILD_DATE }}
          artifacts: ${{ github.workspace }}/firmware-${{ env.DEVICE_NAME }}-${{ env.BUILD_DATE }}.zip
          replacesArtifacts: true
          allowUpdates: true
          prerelease: false
          body: |
            ### Build Information
            ---
            - Source Code: ${{ env.SOURCE_URL }}
            - Source Code Branch: ${{ env.SOURCE_BRANCH }}
            - Device Platform: ${{ env.DEVICE_PLATFORM }}
            - Device Target: ${{ env.DEVICE_TARGET }}
            - Device Subtarget: ${{ env.DEVICE_SUBTARGET }}
            - Device Name: ${{ env.DEVICE_NAME }}
            - Build Date: ${{ env.BUILD_DATE }}
